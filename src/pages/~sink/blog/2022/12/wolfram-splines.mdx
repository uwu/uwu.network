---
layout: "^layouts/QuietLayout.astro"
title: Splines in Wolfram Mathematica
description: Playing with splines using Mathematica.
pubDate: "2022-12-08"
tags: ["MATH"]
---

{/* important for more than one page using these, hot reloads, etc */}
import NotebookResetter from "^components/quiet/NotebookResetter.astro";
import NotebookCell from "^components/quiet/NotebookCell.astro";
import K from "^components/Katex.astro";

<NotebookResetter />

# Splines in Wolfram Mathematica

The other day, I watched Freya Holmér's new video, *The Continuity of Splines*.
I had previously seen her video on Beziér curves, and this one was equally interesting.

It struck me as I watched this that a lot of the math behind these wasn't all that
complex to quantify, but often just involved a horrendously large amount of
calculation.

This felt, to me, like something that would be perfect to play with in Mathematica,
since I've been playing about with it the past few days anyway,
and perhaps some of those crazy big calculations might be tackled way better by a
computer.

## Mathematica: a brief introduction

You probably know the name Wolfram from Wolfram|Alpha, a web service that connects
a natural language parser to a powerful math and data backend, and a gigantic database.

Mathematica is the original piece of software developed by Wolfram, and, while now featuring
most of the improvements of Alpha, remains at its core a tool for efficent maths and for
all kinds of data analysis, and fun stuff they show on their website.

I'm going to use it here to do some of the really ugly maths behind splines for me.

It uses the Wolfram language, which is very unique, but hopefully you shouldn't get too lost.

## A quick note on built-ins

Mathematica is a very complete program for doing all kinds of mathematical *stuff*.
As such it has a built in set of Beziér functions available, notably `BezierFunction`
and `BezierCurve`.

I will be ignoring these for the most part and building them from scratch,
but they are worth acknowledging, and I may use them to show that my constructions work.
Here is a use example of both, showing both sampling a curve
and rendering a curve using `Graphics`:

<NotebookCell
  cells={[
    `
func = BezierFunction[{\{0, 0}, {1, 1}, {2, 0}, {3, 2}}]
func[0.5]`,
  `BezierFunction[...]`,
  `{1.5, 0.625}`
  ]}
/>

<NotebookCell
  cells={[
    `
ctrlPoints = \{{0, 0}, {1, 1}, {2, -1}, {3, 0}};
Graphics[{
  White, BezierCurve[ctrlPoints],
  Green, Line[ctrlPoints],
  Red,   Point[ctrlPoints]
  }]`,
  ["IMG", "/sink/quiet_beziers/BezierCurve_example.svg"]
  ]}
/>

## Beziér curves

A good place to start with generating curves would be Beziérs - they are very
simple to create but very powerful.

So, let's define a *cubic Beziér* in Mathematica!
I'll use *De Casteljau's construction* of Beziér curves here: nested linear interpolation.

Obviously this means we need linear interpolation first!

<NotebookCell
  cells={[`lerp[a_, b_, t_] := (1 - t)*a + t*b`]}
/>

And then we can nest out our lerps:

<NotebookCell
  cells={[
    `
cubicbezier[P0_, P1_, P2_, P3_, t_] :=
 (a = lerp[P0, P1, t];
  b = lerp[P1, P2, t];
  c = lerp[P2, P3, t];
  d = lerp[a, b, t];
  e = lerp[b, c, t];
  lerp[d, e, t])`
  ]}
/>

And finally test it out!:

<NotebookCell
  cells={[
    `cubicbezier[{0, 0}, {1, 1}, {2, 0}, {3, 2}, 0.5]`,
    `{1.5, 0.625}`
  ]}
/>
<NotebookCell
  cells={[
    `BezierFunction[\{{0, 0}, {1, 1}, {2, 0}, {3, 2}}][0.5]`,
    `{1.5, 0.625}`
  ]}
/>

As we can see, this construction of a Beziér curve yields a
valid output for our <K>t</K> values.

## Bernstein from

The Bernstein form of Beziér curves is the form in which
the control points are factored out.
Let's see if we can have Mathematica help us find this form.

The first thing to notice is that this actually can be expanded
to a polynomial:

<NotebookCell
  cells={[
    `dcjBezier = cubicbezier[P0, P1, P2, P3, t]`,
    `
  (1 - t) ((1 - t) (P0 (1 - t) + P1 t)
+ t (P1 (1 - t) + P2 t))
+ t ((1 - t) (P1 (1 - t) + P2 t)
+ t (P2 (1 - t) + P3 t))`
  ]}
/>

<NotebookCell
  cells={[
    `Expand[%]`,
    `
P0 - 3 P0 t + 3 P1 t
+ 3 P0 t^2 - 6 P1 t^2 + 3 P2 t^2
- P0 t^3 + 3 P1 t^3 - 3 P2 t^3 + P3 t^3`
  ]}
/>

Now if we have Mathematica collect in terms of our control points,
we are left with the Bernstein form of a Beziér curve!:

<NotebookCell
  cells={[
    `Collect[%, {P0, P1, P2, P3}]`,
    `
  P0 (   -t^3 + 3 t^2 - 3 t + 1)
+ P1 (  3 t^3 - 6 t^2 + 3 t)
+ P2 (- 3 t^3 + 3 t^2)
+ P3 (    t^3)`
  ]}
/>

Note that that expansion is actually a necessary step to get Mathematica
to collect our terms the way we want, which is interesting.

We can also have Mathematica verify that this Bernstein form is actually
identical to the DeCasteljau construction
(notice we grabbed this into `dcjBezier` earlier):

<NotebookCell
  cells={[
    `FullSimplify[Equivalent[dcjBezier, %]]`,
    `True`
  ]}
/>

Worth mentioning that `==` (`Equal[]`) also returns `True` for this.
I have no idea what the difference is, but I figured `Equivalent`
is usually stricter in a mathematical sense.

## Polynomial Coefficients

Another form of the Beziér curve is as a polynomial of <K>t</K>.

To have this calculated for us, we can ask Mathematica to collect the
DeCasteljau construction for <K>t</K>:

<NotebookCell
  cells={[
    `Collect[dcjBezier, t]`,
    `
          P0
+   t (-3 P0 + 3 P1)
+ t^2 ( 3 P0 - 6 P1 + 3 P2)
+ t^3 (  -P0 + 3 P1 - 3 P2 + P3) `
  ]}
/>

interestingly, expanding the DCJ construction is *not* necessary here.
Not only is it equivalent, but it actually works out identical in
structure as well as value.

This is tested with `SameQ` or `===`:

<NotebookCell
  cells={[
    `
(* unrelated example of == vs === *)
Reduce[a^2 - b*a ==  a (-b + a)]
       a^2 - b*a === a (-b + a)

Collect[dcjBezier, t] === Collect[Expand[dcjBezier], t]`,
    `True`,
    `False`,
    `True`
  ]}
/>

## Matrix form

One of the more fascinating ideas I noticed from Freya's video on the splines
was that any spline can be represented by a multiplication of three matrices:
1. A one-row matrix of powers of <K>t</K>
2. A big matrix of numbers - the *characteristic matrix*
3. A one-column matrix of control points

The characteristic matrix is the only thing that changes between different
kinds of splines. So, let's find it for Beziérs!

This is more complex than simple algebraic manipulation, however.

Converting a polynomial directly into a matrix isn't something Mathematica
can directly do, so we're going to need to get creative.

We will give Mathematica a matrix form with a set of unfilled variables in
the characteristic matrix.

We will then tell it to solve the matrix form equal to our Beziér equation,
enforcing that it must hold for all values of our control points and <K>t</K>.

<NotebookCell
  cells={[
    `
SolveAlways[
  (* powers of t matrix *)
 \{{1, t, t^2, t^3},
  {1, t, t^2, t^3},
  {1, t, t^2, t^3},
  {1, t, t^2, t^3}} .
  (* characteristic matrix *)
 \{{ca, cb, cc, cd},
  {ce, cf, cg, ch},
  {ci, cj, ck, cl},
  {cm, cn, co, cp}} .
  (* control point matrix *)
 \{{P0, P0, P0, P0},
  {P1, P1, P1, P1},
  {P2, P2, P2, P2},
  {P3, P3, P3, P3}} == dcjBezier,
  (* all of these values are unknowns *)
  {P0, P1, P2, P3, t}
  ]`,
  `
\{{
  ca -> 1, cb -> 0, cc -> 0, cd -> 0,
  ce -> -3, cf -> 3, cg -> 0, ch -> 0,
  ci -> 3, cj -> -6, ck -> 3, cl -> 0,
  cm -> -1, cn -> 3, co -> -3, cp -> 1
  }}`
  ]}
/>

If we apply the returned *set of rules* to a matrix:
<NotebookCell
  cells={[
    `
(\{{cp, cl, ch, cd},
  {co, ck, cg, cc},
  {cn, cj, cf, cb},
  {cm, ci, ce, ca}} /. %)[[1]] // MatrixForm`,
  ["MATRIX", [
    [1,0,0,0],
    [-3,3,0,0],
    [3,-6,3,0],
    [-1,3,-3,1]
  ]]
  ]}
/>

One characteristic matrix, right there!

A quick note that in my calculations I assumed that matrices were lists of rows.
Mathematica actually treats them as lists of columns.

While this has not affected the calculation result, for displaying,
I flipped around the rows and columns so that it looks correct.

That's why the matrix I sub into is a bit weird.

### Verifying the matrix form

At first glance, the matrix form may look *really* weird.

What are all these numbers doing?
Isn't it magical how one matrix of integers defines all the
unique traits of a Beziér curve outside of being cubic?

Well lets verify that this is actually true, by plugging in a random value!

We'll use the control points <K>(0,0), (1,1), (2,0), (3,2)</K> and <K>t=0.5</K>.

<NotebookCell
  cells={[
    `
cubicbezierMatrix[P0_, P1_, P2_, P3_, t_] :=
  (\{{1, t, t^2, t^3},
    {1, t, t^2, t^3},
    {1, t, t^2, t^3},
    {1, t, t^2, t^3}} .
   \{{1, 0, 0, 0},
    {-3, 3, 0, 0},
    {3, -6, 3, 0},
    {1, 3, -3, 1}} .
   \{{P0, P0, P0, P0},
    {P1, P1, P1, P1},
    {P2, P2, P2, P2},
    {P3, P3, P3, P3}})[[1]][[1]]`
  ]}
/>

<NotebookCell
  cells={[
    `
cubicbezierMatrix[{0, 0}, {1, 1}, {2, 0}, {3, 2}, 0.5]
cubicbezier      [{0, 0}, {1, 1}, {2, 0}, {3, 2}, 0.5]`,
    `{1.5, 0.625}`,
    `{1.5, 0.625}`
  ]}
/>

One thing I am yet to figure out is that Mathematica actually does not think
that these two forms *are* fully equivalent.

No idea why.

<NotebookCell
  cells={[
    `
FullSimplify[
 cubicbezier[P0, P1, P2, P3, t] ==
  cubicbezierMatrix[P0, P1, P2, P3, t]]
FullSimplify[
 Equivalent[cubicbezier[P0, P1, P2, P3, t],
  cubicbezierMatrix[P0, P1, P2, P3, t]]]
FullSimplify[
 ForAll[{P0, P1, P2, P3, t},
  cubicbezier[P0, P1, P2, P3, t] ==
   cubicbezierMatrix[P0, P1, P2, P3, t]]]`,
    `P0 t == 0`,
    `
P0
+ 3 (-P0 + P1) t
+ 3 (P0 - 2 P1 + P2) t^2
+ (P0 + 3 P1 - 3 P2 + P3) t^3
≡
-P0 (-1 + t)^3
+ t (3 P1 (-1 + t)^2
+ t (3 P2 - 3 P2 t + P3 t))`,
    `False`
  ]}
/>

## Lets make some pretty pictures!

We will start by generating a load of points on our curve by using `Table`.

<NotebookCell
  cells={[
    `
plotPoints = Table[
  cubicbezier[{5, 2}, {1, 2}, {0, 3}, {2, 3}, t],
  {t, 0, 1, 0.01}
  ];`
  ]}
/>

And then plot all the <K>(x,y)</K> pairs, drawing lines between them,
and for comparison draw a Mathematica built-in Beziér curve:

<NotebookCell
  cells={[
    `
ListLinePlot[
  plotPoints,
  AxesOrigin -> {0, 0}, (* fix distortion *)
  AxesStyle -> White
  ]
Graphics[{
  White,
  BezierCurve[\{{5, 2}, {1, 2}, {0, 3}, {2, 3}}]
  }]`,
    ["IMG", "/sink/quiet_beziers/plotted_custom_bezier.svg"],
    ["IMG", "/sink/quiet_beziers/plotted_custom_real_comparison.svg"]
  ]}
/>

## Derivatives

The derivative of a function tells you how that function changes over time.

One way to think of a derivative is that if your function models position,
its derivative models velocity: the rate of change of position.

With that in mind, what if we could plot the velocity of our Beziér curves?

Let's start by differentiating the DeCasteljau construction of our bezier:

(Let's also keep the more interesting control points from the pretty pictures!)

<NotebookCell
  cells={[
    `
bezier = cubicbezier[{5, 2}, {1, 2}, {0, 3}, {2, 3}, t];
derivative =
  D[
    bezier,
    t
    ] // Simplify`,
    `{6 (-2 + 3 t), -6 (-1 + t) t}`
  ]}
/>

And to visualise this we could do with a custom plotting function.
This function should handle:
 - sampling points
 - drawing the plot
 - correcting the weird skewing done by the automatic axes
 - apply useful styles

And as one additional job that will be useful here,
adding an arrowhead to make it clear how the graph is moving as <K>t</K> increases.

<NotebookCell
  cells={[
    `
directionedPlot[f_, range_] :=
 ListLinePlot[
   Table[f, {t, 0, 1, 0.01}],
   PlotRange -> range,
   AspectRatio -> 1,
   Mesh -> 6,
   MeshShading -> {Arrowheads[Medium]},
   MeshStyle -> Opacity[0],
   MeshFunctions -> {"ArcLength"},
   AxesStyle -> White
   ] /. Line -> Arrow`
  ]}
/>

And finally let's plot!

<NotebookCell
  cells={[
    `
directionedPlot[bezier, \{{0, 5}, {0, 5}}]
directionedPlot[derivative, \{{-15, 15}, {-15, 15}}]`,
    ["IMG", "/sink/quiet_beziers/derivatives_plot1.svg"],
    ["IMG", "/sink/quiet_beziers/derivatives_plot2.svg"]
  ]}
/>

As you can see, this curve starts at the right and heads left.

This corresponds to the fact that the derivative starts on the left of
this graph. In fact, as the derivative begins at a point where <K>y=0</K>,
we know that the very start of the curve is actually tangent to a horizontal
line.

This is evident when looking at a picture:

<NotebookCell
  cells={[
    `
Graphics[{
    White,
    BezierCurve[\{{5, 2}, {1, 2}, {0, 3}, {2, 3}}],
    Green,
    Line[\{{5, 2}, {6, 2}}]
  }]`,
    ["IMG", "/sink/quiet_beziers/derivatives_3_tangent.svg"]
  ]}
/>

We can also see that as time goes on, it starts to slowly point upwards:
this corresponds to when the leftmost part of the curve where it indeed moves upwards.

Finally, the derivative comes back down, while continuing right.
This means the curve moves towards the right while moving upwards less.

Let's now look at the *second derivative* - the derivative of the derivative.

<NotebookCell
  cells={[
    `
secondDerivative = D[derivative, t]
directionedPlot[secondDerivative, \{{0, 20}, {-10, 10}}]`,
    `{18, -6 (-1 + t) - 6 t}`,
    ["IMG", "/sink/quiet_beziers/derivatives_4_second.svg"]
  ]}
/>

This shows us two things:
 - the velocity is moving right at a constant speed
   * the acceleration is to the right but not moving
 - the velocity moves upwards at first, but then downwards
   * the 2nd derivative shows an acceleration from up to downwards


## Continuity

Continuity is the concept of multiple curves being connected in some ways.

This is the core idea that takes a collection of curves and gives you a spline.

If you want to learn about continuity in depth, please watch the video I mentioned at the start,
the *Continuity of Splines*, it is truly exceptional and explains it much more in depth.

### Testing continuity between two Beziér curves

We'll start with the simplest form of continuity testing, <K>C^0</K> continuity.

This is where two curves in the spline are connected end-to-end.

That is, given two Beziérs in terms of <K>t</K>, <K>a</K> and <K>b</K>, <K>a(1)=b(0)</K>.

This, we can do in Mathematica as well:

<NotebookCell
  cells={[
    `
bezier1[t_] = cubicbezier[{5, 2}, {1, 2}, {0, 3}, {2, 3}, t];
bezier2[t_] = cubicbezier[{2, 3}, {2, 4}, {3, 2}, {3, 4}, t];

bezier1[1]
bezier2[0]`,
    `{2, 3}`,
    `{2, 3}`
  ]}
/>

These two are <K>C^0</K> continuous because they touch at the ends.
If you want some help visualising this, here's a picture:

<NotebookCell
  cells={[
    `
Graphics[{
  White,
  BezierCurve[\{{5, 2}, {1, 2}, {0, 3}, {2, 3}}],
  Green,
  BezierCurve[\{{2, 3}, {2, 4}, {3, 2}, {3, 4}}]
  }]`,
  ["IMG", "/sink/quiet_beziers/continuity_1_c0.svg"]
  ]}
/>

To test for <K>C^1</K> continuity, the *derivatives* of the two curves
must have the same value at the ends.

In practice, this means that the two curves are tangent at their ends, and touching,
and the control points are equidistant from the point.

If we pick a different pair of curves:

<NotebookCell
  cells={[
    `
bezier3[t_] = cubicbezier[{5, 2}, {1, 2}, {0, 3}, {2, 3}, t];
bezier4[t_] = cubicbezier[{2, 3}, {4, 3}, {3, 2}, {3, 3}, t];

bezier3'[1]
bezier4'[0]`,
    `{6, 0}`,
    `{6, 0}`
  ]}
/>

They have equivalent derivatives (note the <K>\prime</K> prime symbol), so they are <K>C^1</K> continuous.

If we plot the curves:

<NotebookCell
  cells={[
    `
Graphics[{
  White,
  BezierCurve[\{{5, 2}, {1, 2}, {0, 3}, {2, 3}}],
  Green,
  BezierCurve[\{{2, 3}, {4, 3}, {3, 2}, {3, 3}}]
  }]`,
  ["IMG", "/sink/quiet_beziers/continuity_2_c1.svg"]
  ]}
/>

As you can see, <K>C^1</K> continuous curves look a lot smoother.

If we graph the derivative instead
(excuse the long plot function, its a slightly modified version of `directionedPlot`):

<NotebookCell
  cells={[
    `
points = Join[
   Table[bezier3'[t], {t, 0, 1, 0.001}],
   Table[bezier4'[t], {t, 0, 1, 0.001}]
   ];

ListLinePlot[
  points,
  PlotRange -> \{{-10, 10}, {-10, 10}},
  AspectRatio -> 1,
  Mesh -> 6,
  MeshShading -> {Arrowheads[Medium]},
  MeshStyle -> Opacity[0],
  MeshFunctions -> {"ArcLength"},
  AxesStyle -> White
  ] /. Line -> Arrow`,
    ["IMG", "/sink/quiet_beziers/continuity_3_c1d.svg"]
  ]}
/>

You can see here that the derivatives are connected.

You can also see this is not <K>C^2</K> continuous as there is a sharp corner,
so the second derivative (acceleration) will have a discontinuity (jump).

### G Continuity

<K>G^n</K> continuity is less strict, and can define continuities
such as tangent but not equal velocity.

Again, see *The Continuity of Splines* for more info.

### Enforcing continuity

One important thing to note about continuity, is that when enforcing it,
(at least with Beziér splines!) we lose local control of the curve,
and moving control points can cause the rest of the curve to move incredibly
unpredictably.

Once again, *The Continuity of Splines* demonstrates this fact better that I could
here.

Nonetheless, let's see if we can enforce continuous splines!

We can enforce that they must be <K>C^0</K>,
by reusing the last point of the first curve as the first point of the second curve:

<NotebookCell
  cells={[
    `
Simplify[
  cubicbezier[P0, P1, P2, P3, t] ==
  cubicbezier[P4, P5, P6, P8, t - 1],
  {t == 1}
 ]`,
    `P3 == P4`
  ]}
/>

*From now on, we will treat <K>P_3</K> as this point, and the numbers of the subsequent control points will shift by one. (<K>P^5</K> is now <K>P^4</K> etc)*

For <K>C^1</K> continuity, we have to surrender control over <K>P_4</K>.

We can find this out by telling Mathematica that the curve's derivatives equal
at <K>t=1</K> and asking it to simplify the expression:

<NotebookCell
  cells={[
    `
Simplify[
  D[cubicbezier[P0, P1, P2, P3, t], t] ==
  D[cubicbezier[P3, P4, P5, P6, t - 1], t],
  {t == 1}
  ]`,
  `P2 + P4 == 2 P3`
  ]}
/>

The result it has given us is the constraint for <K>C^1</K> continuity,
which can be rearranged to <K>{`P_4=2P_3 -P_2`}</K>,
or if you prefer, <K>{`\\frac{P_2+P_4}{2}=P_3`}</K>: <K>P_3</K> is the mean of <K>P_2</K> and <K>P_4</K> -
in the middle of them!

If we want <K>C^2</K> continuity, however, we lose a lot more control:

<NotebookCell
  cells={[
    `
Simplify[
  D[cubicbezier[P0, P1, P2, P3, t], {t, 2}] ==
  D[cubicbezier[P3, 2 P3 - P2, P5, P6, t - 1], {t, 2}],
  {t == 1}
  ]`,
  `P1 + 4 P3 == 4 P2 + P5`
  ]}
/>

This new constraint locks in the position of <K>P_5</K> as well.

The geometric intuition for this constraint is a lot less useful,
but we now only have control over the end points of each Beziér,
plus the control points of the first curve.

The constraint is more usefully rearranged to: <K>P_5=P_1+4P_3-4P_2</K>.

If you watch the relevant part of *The Continuity of Splines*,
it is quite convincingly and satisfying shown that going higher,
to <K>C^3</K> continuity in a Beziér spline implies <K>C^\infty</K> continuity for that spline,
as you lose control over all but the first curve's control points,
and your spline becomes the equivalent of just letting <K>t>1</K> for the first curve in the spline.

*For all of these constraints* they can be generalised higher by just adding more curves,
more control points, and requiring continuity at all relevant integer values of <K>t</K>
instead of just at 1.

### Wait what? That's a confident assertion. Prove it!

I assert that, for a cubic Beziér curve, <K>C^3\implies C^\infty</K>,
and also that its equivalent to increasing <K>t>1</K>.

Let's prove it!

Let's define a spline of two cubic Beziérs,
with the control points <K>P_0, P_1, P_2, P_3, P_4, P_5, P_6</K>.

![](/sink/quiet_beziers/infinite_proof_setup.svg)

And construct these in Mathematica and enforce <K>C^3</K> continuity:

<NotebookCell
  cells={[
    `
Simplify[
  D[cubicbezier[P0, P1, P2, P3, t], {t, 3}] ==
  D[cubicbezier[P3, 2 P3 - P2, P1 + 4 P3 - 4 P2, P6, t - 1], {t, 3}],
  {t == 1}
  ]`,
  `P0 + 12 P2 + P6 == 6 P1 + 8 P3`
  ]}
/>

If we now consider our rules:
- <K>P_4 = 2P_3-P_2</K>
- <K>P_5 = P_1 + 4P_3 - 4P_2</K>
- <K>P_0 + 12 P_4 + P_6 = 6 P_1 + 6 P_5</K>

And put them in terms of <K>P_4</K>, <K>P_5</K>, and <K>P_6</K>:

- <K>P_4 = 2P_3-P_2</K>
- <K>P_5 = P_1 + 4P_3 - 4P_2</K>
- <K>P_6 = 6 P_1 + 6P_5 - P_0 - 12 P_4</K>

And solve for individual points:

<NotebookCell
  cells={[
    `
proofP4 = 2 proofP3 - proofP2                          // FullSimplify
proofP5 = proofP1 + 4 proofP3 - 4 proofP2              // FullSimplify
proofP6 = 6 proofP1 + 6 proofP5 - proofP0 - 12 proofP4 // FullSimplify`,
  `-proofP2 + 2 proofP3`,
  `proofP1 - 4 proofP2 + 4 proofP3`,
  `-proofP0 + 12 (proofP1 - proofP2)`
  ]}
/>

So the points of the second Beziér curve are fully constrained by the first curve:
- <K>P_4=2P_3-P_2</K>
- <K>P_5=P_1+4P_3-4P_2</K>
- <K>P_6=12P_1-12P_2-P_0</K>

And if we draw a Beziér with these constraints:

<img src="/sink/quiet_beziers/continuity_4_cinf.svg" class="max-w-130" />

Well, it may be *really fucking big*, but it sure looks smooth as butter!

Now to prove that this is equivalent to increasing <K>t>1</K>...
Well I don't actually have any idea how to do this. //TODO?

## TODO:
- hermite splines and catmull-rom and b-spline
